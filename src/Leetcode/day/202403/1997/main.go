package main

/*
	首次访问房间 i 是第一次访问, i 是奇数，下一天一定要访问 j=nextVisit[i] 房间，简称 '回访'

	由于访问偶数个才能访问下一个房间，所以对于 i 左边的房间，我们一定都访问了偶数次（不然不可能到达i）

	这意味着，当我们从 i 回到 j 时，此时 [j,i-1] 范围内的房间都属于访问偶数次的状态。那么当我们访问
	这个范围内的每个房间时，算上本次访问，访问次数一定是奇数，所以想要重新回到 i，对于[j,i-1] 范围内
	的每一个房间，我们都需要执行一次 '回访'

	状态设计：
		描述				   		奇偶性
	1. 访问房间 i 之前 			 偶数
	2. 访问到房间 i    			 奇数
	3. 回访完毕，重新回到房间 i		 偶数

	这说明 "访问到房间 i 且次数是奇数" 到 "访问到房间 i 且次数为偶数" 是一个完整的周期，适合作为状态，
	即定义 f[i] 表示从 "访问到房间 i 且次数是奇数" 到 "访问到房间 i 且次数为偶数" 所需要的天数

	状态转移方程：
	由于 [j,i-1] 范围内的每个房间都需要 '回访',所以需要把这个范围内的 f 值都加起来，再算上房间 i 需
	要访问 2 次，于是得到如下状态转移方程
	(1)						f[i] = 2 + f[k]  {k=j j->i-1}
	其中和式可以用前缀和优化
	定义前缀和 s[0] = 0, s[i+1] = f[i]  {j=0  j->i}
	于是 (1) 简化为
	(2)						f[i] = 2 + s[i] - s[j]
	对于前缀和 s，有如下递推式子
							s[i+1] = s[i] + f[i]
	(2)(3)联立得
							s[i+1] = s[2]*2 - s[j] + 2

*/

func firstDayBeenInAllRooms(nextVisit []int) int {
	const mod = 1_000_000_007
	n := len(nextVisit)
	s := make([]int, n)
	for i, j := range nextVisit[:n-1] {
		s[i+1] = (s[i]*2 - s[j] + 2 + mod) % mod // 避免算出负数
	}
	return s[n-1]
}
