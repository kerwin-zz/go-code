package main

/*
动态规划：O(nm)
状态表示：f[i][j] s[0~i)的字符串与p[0~j)的字符串是否匹配
状态转移：
	1. p[j-1]是字母而且与s[i-1]相等，那么当前f[i][j]是否匹配就依赖于f[i-1][j-1]
	2. p[j-1]是'.'那么肯定与s[i-1]相等，当前f[i][j]是否匹配就依赖于f[i-1][j-1]
	情况1 2 类似 可以在代码中一起判断
	3. p[j-1]根据前面字母的多次重复还是0次重复分为两种情况：
		3.1 如果是0次重复字符那么当前的p[j-1]='*'和p[j-2]都可以忽略不计。那么f[i][j] = f[i][j-2]
		3.2 如果是多次重复且p[j-2]与s[i-1]相等或者p[j-2]=='.'。 那么f[i][j] = f[i-1][j]

时间复杂度分析：n表示s的长度，m表示p的长度，总共nm个状态，状态转移复杂度O(1)，所以总时间复杂度是O(nm).
*/

func isMatch(s string, p string) bool {
	n, m := len(s), len(p)
	f := make([][]bool, n+1)
	for i := range f {
		f[i] = make([]bool, m+1)
	}

	f[0][0] = true // 空正则只有一种情况为true
	for i := 0; i <= n; i++ {
		for j := 1; j <= m; j++ {
			// 非空正则分为两种情况 * 和 非*
			if p[j-1] != '*' {
				if i >= 1 && (s[i-1] == p[j-1] || p[j-1] == '.') {
					f[i][j] = f[i-1][j-1]
				}
			} else {
				if j >= 2 && f[i][j-2] { // 0次重复字符
					f[i][j] = true
				} else if i >= 1 && j >= 2 && (p[j-2] == '.' || p[j-2] == s[i-1]) && f[i-1][j] {
					f[i][j] = true
				}
			}
		}
	}

	return f[n][m]
}
