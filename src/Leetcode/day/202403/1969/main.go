package main

/*
	[1,2^p-1] 内的所有正数分为两组，小于 2^(p-1) 的为一组，记作 A，其余的为另一组，记作 B。
	例如 p = 3时，A = [1,2,3], B = [4,5,6,7]
	B 中除了 2^p-1 = 7 外，其余均数可以和 A 组中的数一一配对，其中配对的两个数和为 2^p-1 = 7
	例如 p=3 时我们有三个数对 (6,1),(5,2),(4,3)，写成二进制为 (110,001),(101,010),(100,011)。
	如此构造，数对内没有相同的比特位（一个是 000 另一个必然是 111），我们可以完美地按照上述交换流程交
	换，交换后的结果为 2p−2=6 和 1。
	交换后，每一对的乘积为 2^p-2 = 6，这一共有 2^(p-1)-1 = 3堆，再乘上不参与配对的 2^p-1 = 7
	最小成绩为 7*6*6*6 = 7 * 6^3
	所以，一般地，最小乘积为
						(2^p-1)·(2^p-2)^[2^(p-1)-1]


*/

const mod = 1_000_000_007

func pow(x, p int) int {
	res := 1
	for x %= mod; p != 0; {
		if p&1 == 1 {
			res = res * x % mod
		}
		x = x * x % mod
		p >>= 1
	}
	return res
}

func minNonZeroProduct(p int) int {
	k := 1 << p
	return (k - 1) % mod * pow(k-2, k>>1-1) % mod
}

func main() {}
