package main

/*
	给你一个二进制数组 nums 。
	你可以对数组执行以下操作 任意 次（也可以 0 次）：
	· 选择数组中 任意 一个下标 i ，并将从下标 i 开始一直到数组末尾 所有 元素 反转 。
	反转 一个元素指的是将它的值从 0 变 1 ，或者从 1 变 0 。

	请你返回将 nums 中所有元素变为 1 的 最少 操作次数。
*/

/*
	方法一：记录操作次数
	由于 nums[i] 会被发生在 i 左侧的操作影响，我们先从最左边的 nums[0] 开始思考。
	讨论是否要在 i=0 处操作：
	· 如果 nums[0]=1，不需要操作，问题变成剩下 n−1 个数的子问题。
	· 如果 nums[0]=0，一定要操作，问题变成剩下 n−1 个数（在操作次数是 1 的情况下）的子问题。

	对后续元素来说，由于反转偶数次等于没反转，所以只需考虑操作次数的奇偶性。
	一般地，设遍历到 x=nums[i] 时，之前执行了 k 次操作，分类讨论：
	· 如果 x=0 且 k 是奇数，或者 x=1 且 k 是偶数，那么这 k 次操作执行完后 nums[i] 变成 1。所以如果 x != k mod 2，则不需要操作。
	· 如果 x=0 且 k 是偶数，或者 x=1 且 k 是奇数，那么这 k 次操作执行完后 nums[i] 变成 0。所以如果 x == k mod 2，则一定要操作。
*/

func minOperations(nums []int) (ans int) {
	for _, x := range nums {
		if x == ans%2 {
			ans++
		}
	}
	return
}

/*
	方法二：比较相邻元素
	在从左到右遍历的过程中：
	· 如果 nums[0]=0，那么要选择下标 i=0 操作一次。
	· 如果 nums[i]=nums[i−1]=0，那么发生在 nums[i−1] 上的反转次数必然是奇数，由于（遍历到 i 时）从 i−1 到数组末尾的元素都被反转了
	  奇数次，所以在 nums[i] 上的反转次数也是奇数，所以当我们遍历到 i 时，nums[i] 一定被反转成了 1，所以无需选择下标 i 操作。
	· 如果 nums[i]=nums[i−1]=1，那么发生在 nums[i−1] 上的反转次数必然是偶数，所以同样的，发生在 nums[i] 上的反转次数也是偶数，所以
	  当我们遍历到 i 时，nums[i] 仍然是 1，所以无需选择下标 i 操作。
	· 如果 nums[i]=1 且 nums[i−1]=0，那么发生在 nums[i−1] 上的反转次数必然是奇数，所以同样的，发生在 nums[i] 上的反转次数也是奇数，
	  所以当我们遍历到 i 时，nums[i] 一定被反转成了 0，所以一定要选择下标 i 操作。
	· 如果 nums[i]=0 且 nums[i−1]=1，那么发生在 nums[i−1] 上的反转次数必然是偶数，所以同样的，发生在 nums[i] 上的反转次数也是偶数，
	  所以当我们遍历到 i 时，nums[i] 仍然是 0，所以一定要选择下标 i 操作。

	算法
	1. 初始化答案 ans=nums[0]⊕1，其中 ⊕ 表示异或。如果 nums[0]=0，那么要选择下标 i=0 操作一次。
	2. 从 i=1 开始向右遍历 nums。
	3. 把 nums[i]⊕nums[i−1] 加到 ans 中。如果 nums[i] 和 nums[i−1] 不相等，或者说异或结果等于 1，那么必须要选择下标 i 操作。
	4. 遍历结束，返回 ans。
*/

func minOperations2(nums []int) int {
	ans := nums[0] ^ 1
	for i := 1; i < len(nums); i++ {
		ans += nums[i-1] ^ nums[i]
	}
	return ans
}
