package main

/*
	四、1:1 翻译成递推
	具体来说，f[i][j][k] 的定义和 dfs(i,j,k) 是一样的。

	状态转移方程：
		f[i][j][k] = val + max { f[i+1][j-1][k-1], f[i+1][j-1][k], f[i+1][j-1][k+1],
								 f[i+1][j][k-1],   f[i+1][j][k],   f[i+1][j][k+1],
								 f[i+1][j+1][k-1], f[i+1][j+1][k], f[i+1][j+1][k+1] }
		val = grid[i][j] + grid[i][k]   j != k
		val = grid[i][j]				j == k


	但是，这种定义方式没有状态能表示递归边界，即 j = -1, k = -1 这种出界情况。
	解决方法：在每个 f[i] 的最左边和最上边各插入一排状态，那么其余状态全部向右和向下偏移一位，把 f[i][j][k] 变成 f[i][j+1][k+1]
	修改后的 f[i][j+1][k+1] 表示 A 从 (i,j) 出发，B 从 (i,k) 出发，到达最后一行，可以得到的樱桃个数的最大值。

	修改后的状态转移方程为：
		f[i][j+1][k+1] = val + max { f[i+1][j][k],   f[i+1][j][k+1],   f[i+1][j][k+2],
								 	 f[i+1][j+1][k], f[i+1][j+1][k+1], f[i+1][j+1][k+2],
								 	 f[i+1][j+2][k], f[i+1][j+2][k+1], f[i+1][j+2][k+2] }
	初始值 f[i][j][k] = 0
	答案为 f[0][1]n]

	循环范围：
	代码实现时，我们还需要讨论清楚 j 和 k 的范围。
	对于 A 来说，即使从 (0,0) 开始，每一步都往右下走，也不会出现 j > i 的情况， 所以 j 的范围为
				0 <= j <= min(n-1,i)
	对于 B 来说，即使从 (0,n-1) 开始，每一步都往左下走，也不会出现 k < n-1-i 的请看，所以 k 的范围为
				max(0,n-1-i) <= k <= n-1
	进一步地，我们可以假定 A 走的是两条路径的做轮廓，B 走的是两条路径的右轮廓（求并集后看不出区别），所以只需计算 k >= j 的状态。
	这样转换后，可以发现，A 和 B 走到同一个格子是没有意义的。如果走到同一个格子 (i,j)，那么 A 也可以走到 (i,j-1) 或者 B 也可以
	走到 (i,j+1)，从而得到更多的樱桃，所以只需计算 k > j 的状态。
	所以， k的范围可以进一步缩小为
				max(j+1,n-1=i) <= k <= n-1
	如此转换后，状态转移方程中的 val = grid[i][j] + grid[i][k]。

*/

func cherryPickup(grid [][]int) int {
	m, n := len(grid), len(grid[0])
	f := make([][][]int, m+1)
	for i := range f {
		f[i] = make([][]int, n+2)
		for j := range f[i] {
			f[i][j] = make([]int, n+2)
		}
	}
	for i := m - 1; i >= 0; i-- {
		for j := 0; j < min(n, i+1); j++ {
			for k := max(j+1, n-1-i); k < n; k++ {
				f[i][j+1][k+1] = max(
					f[i+1][j][k], f[i+1][j][k+1], f[i+1][j][k+2],
					f[i+1][j+1][k], f[i+1][j+1][k+1], f[i+1][j+1][k+2],
					f[i+1][j+2][k], f[i+1][j+2][k+1], f[i+1][j+2][k+2],
				) + grid[i][j] + grid[i][k]
			}
		}
	}
	return f[0][1][n]
}
