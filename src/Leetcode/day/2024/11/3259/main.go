package main

/*
	来自未来的体育科学家给你两个整数数组 energyDrinkA 和 energyDrinkB，数组长度都等于 n。这两个数组分别代表 A、B 两种不同能量饮料每小时所能提供的强化能量。

	你需要每小时饮用一种能量饮料来 最大化 你的总强化能量。然而，如果从一种能量饮料切换到另一种，你需要等待一小时来梳理身体的能量体系（在那个小时里你将不会获得任何强化能量）。

	返回在接下来的 n 小时内你能获得的 最大 总强化能量。

	注意 你可以选择从饮用任意一种能量饮料开始。
*/

/*
	一、寻找子问题
	例如 a=[1,3,1,2,3], b=[3,1,1,2,3]。
	如果最后一个数我们选了 a[4]=3，那么：
	· 继续选 a 中的元素，那么下一个数选 a[3]=2，需要解决的问题为：从下标 [0,3] 中选数字，且最后选的是 a[3] 的情况下，所选元素之和的最大值。
	· 改成选 b 中的元素，那么下一个数选 b[2]=1，需要解决的问题为：从下标 [0,2] 中选数字，且最后选的是 b[2] 的情况下，所选元素之和的最大值。
	这些问题都是和原问题相似的、规模更小的子问题，可以用递归解决。

	二、状态定义与状态转移方程
	因为要解决的问题都形如「从下标 [0,i] 中选数字，且最后选的是 a[i] 或 b[i] 的情况下，所选元素之和的最大值」，所以用它作为本题的状态定义
	dfs(i,j)。其中 j=0,1，分别表示最后选的是 a[i] 还是 b[i]。
	为方便实现，把 a 和 b 加到一个长为 2 的二维数组 c 中。
	分类讨论：
	· 继续选 c[j] 中的元素，那么下一个数选 c[j][i−1]，需要解决的问题为：从下标 [0,i−1] 中选数字，且最后选的是 c[j] 中的元素的情况下，
	  所选元素之和的最大值，即 dfs(i−1,j)。
	· 改成选 c[j⊕1] 中的元素，那么下一个数选 c[j⊕1][i−2]，需要解决的问题为：从下标 [0,i−2] 中选数字，且最后选的是 c[j⊕1] 中的元素的
	  情况下，所选元素之和的最大值，即 dfs(i−2,j⊕1)。其中 ⊕ 为异或运算，通过异或 1，可以把 0 变成 1，把 1 变成 0。

	这两种情况取最大值，就得到了 dfs(i,j)，即
						dfs(i,j)=max(dfs(i−1,j),dfs(i−2,j⊕1))+c[j][i]
	递归边界：dfs(−2,j)=dfs(−1,j)=0。没有元素可以选了。
	递归入口：枚举最后一个数选的是 a[n−1] 还是 b[n−1]，取最大值，即 max(dfs(n−1,0),dfs(n−1,1))，也就是答案。
*/

// 记忆化
func maxEnergyBoost(a []int, b []int) int64 {
	n := len(a)
	c := [2][]int{a, b}
	memo := make([][2]int64, n)
	var dfs func(int, int) int64
	dfs = func(i, j int) int64 {
		if i < 0 {
			return 0
		}
		p := &memo[i][j]
		if *p == 0 {
			*p = max(dfs(i-1, j), dfs(i-2, j^1)) + int64(c[j][i])
		}
		return *p
	}
	return max(dfs(n-1, 0), dfs(n-1, 1))
}

/*
	具体来说，f[i+2][j] 的定义和 dfs(i,j) 的定义是一样的，都表示从下标 [0,i] 中选数字，且最后选的是 a[i] 或 b[i] 的情况下，所选元素之和的最大值。
	这里 +2 是为了把 dfs(−2,j) 和 dfs(−1,j) 这两个状态也翻译过来，这样我们可以把 f[0] 和 f[1] 作为初始值。

	相应的递推式（状态转移方程）也和 dfs 一样（注意 +2）：
					f[i+2][j]=max(f[i+1][j],f[i][j⊕1])+c[j][i]
	初始值 f[0][j]=f[1][j]=0，翻译自递归边界 dfs(−2,j)=dfs(−1,j)=0。
	答案为 max(f[n+1][0],f[n+1][1])，翻译自递归入口 max(dfs(n−1,0),dfs(n−1,1))。
*/

// dp
func maxEnergyBoost2(a, b []int) int64 {
	n := len(a)
	f := make([][2]int64, n+2)
	for i, x := range a {
		f[i+2][0] = max(f[i+1][0], f[i][1]) + int64(x)
		f[i+2][1] = max(f[i+1][1], f[i][0]) + int64(b[i])
	}
	return max(f[n+1][0], f[n+1][1])
}
