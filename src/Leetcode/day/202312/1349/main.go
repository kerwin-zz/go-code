package main

/*
	例子：
	#.##.#
	.####.
	#.##.#
	对应二进制：二进制数是从右往左读的。
	010010
	100001
	010010
*/

// dfs1、2:枚举选哪个
/*
	dfs(i,j) 表示在第 i 排的状态为 j 的情况下，前 i 排的最大学生数
	例子 1 的第三排对应的二进制数 010010，分类讨论：
	1. 如果第三排没有学生（000000），那么需要解决的问题为：
		在第二排的座位状态为 100001 的情况下，前两排最多可以坐多少个学生
	2. 如果第三排的左边有学生（000001），那么需要解决的问题为：
		在第二排的座位状态为 100000 的情况下，前两排最多可以坐多少个学生
	3. 如果第三排的右边有学生（100000），那么需要解决的问题为：
		在第二排的座位状态为 000001 的请看下，前两排最多可以坐多少个学生
	4. 如果第三排的左右都有学生（100001），那么需要解决的问题为：
		在第二排的座位状态为 000000 的情况下，前两排最多可以坐多少个学生
	把前两排的最大学生个数加上第三排的学生个数，取最大值，就得到了 dfs(i,j)，即
				dfs(i,j) = max{dfs(i-1,t)+|s|}  s 属于 j
	其中：
	1. s 表示坐在第 i 排，是 j 的子集，且 s 的二进制数中不能有两个 1 是相邻的。
	判断二进制数中有没有两个 1 相邻，可以用 (s & (s >> 1)) == 0，如果有两个 1
	相邻，那么左边的 1 右移一位后，与右边的 1 按位与（AND）必然是 1。当然，写成
	(s & (s << 1)) == 0 也是可以的
	2. |s| 表示坐在第 i 排的学生个数，即 s 的二进制数中 1 的个数，可以直接用库函数解决
	3. t 表示第 i-1 排的可用座位
		0100100 假设这一排有两个学生，二进制数记作 s
		0010010 第一种不能做人的方式用 s>>1 表示。
		1001000 第二种不能坐人的位置用 s<<1 表示。
		1011010 这两种求并集（或运算）就是前一排不能做人的位置，用 s<<1 | s>>1 表示
		设第 i-1 排的可用位置位 Ai-1,去掉其中不能坐人的位置，得
		t = Ai-1 &~ (s<<1 | s>>1)

	单第一排的可用座位位 j 时，最多可以坐多少个学生？
	解决：贪心
	最低位的 1 一定可选
	lb = j & -j // 求最低位的 1
	lowbit 和它左边的比特位: lb<<1 | lb = lb*3
	这两个比特位置 0: j &~ (lb*3)
	递归实现:
	dfs(0,j) = dfs(0,j&~(lb*3)) + 1
	dfs(0,0) = 0
*/

// dfs3: 选或不选
/*
	dfs(i,j,k) 表示在第 i 排的剩余待选座位状态位 j，并且已选座位状态为 k 的情况下，前 i 排的最大学生数
	如果还剩下需要选的座位，即 j > 0，分类讨论：
	1. 不选，去掉最低的 1，即 dfs(i,j,k) = dfs(i,j ^ lb, k)
	2. 选，那么去掉最低的 1，其左边相邻比特置 0，同时把最低的 1 加到 k 中，即
		dfs(i,j,k) = dfs(i,j&~(lb*3),k|lb)+1
	这两种情况取最大值。
	如果没有需要选的座位，即 j = 0，那么继续考虑前一排怎么选，从 a[i-1] 中移除不能坐的位置，递归到
		dfs(i-1,a[i-1]&~(k<<1|k>>1),0)。
	递归边界：dfs(0,0,k)=0
	递归入口：dfs(m-1,a[m-1],0)
*/

func main() {}
