package main

import "math"

/*
	给你一个 n x n 的网格 grid ，代表一块樱桃地，每个格子由以下三种数字的一种来表示：
	· 0 表示这个格子是空的，所以你可以穿过它。
	· 1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。
	· -1 表示这个格子里有荆棘，挡着你的路。

	请你统计并返回：在遵守下列规则的情况下，能摘到的最多樱桃数：
	· 从位置 (0, 0) 出发，最后到达 (n - 1, n - 1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为 0 或者 1 的格子）；
	· 当到达 (n - 1, n - 1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子；
	· 当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为 0 ）；
	· 如果在 (0, 0) 和 (n - 1, n - 1) 之间不存在一条可经过的路径，则无法摘到任何一个樱桃。

*/

/*
	一、 寻找子问题
	从左上角(0,0) 走到右下角 (n-1,n-1)，再走回到左上角 (0,0)，相当于有两条从 (0,0) 到 (n-1,n-1) 的路径。
	我们要计算的，是这两条路径的并集上的樱桃个数的最大值。

	有两条路径要怎么做呢？
	跑两次 DP？先走一边最优路径（把 1 改成 0），再走一遍剩下的最有路径？这个做法是错误的，反例如下：
	0:[1, 1, 1, 1, 0, 0, 0]
	1:[0, 0, 0, 1, 0, 0, 0]
	2:[0, 0, 0, 1, 0, 0, 1]
	3:[1, 0, 0, 1, 0, 0, 0]
	4:[0, 0, 0, 1, 0, 0, 0]
	5:[0, 0, 0, 1, 0, 0, 0]
	6:[0, 0, 0, 1, 1, 1, 1]
	这个反例可以取到所有的樱桃，但两次 DP 的做法，没法取到所有樱桃。

	所以必须 “同时” 考虑两条路径。

	为方便描述，假设有两个人 A 和 B，都从 (0,0) 走到右下角 (n-1,n-1)。

	假设 n = 3，如果 A 最后一步从 (2,1) 走到 (2,2)，B最后一步从 (1,2) 走到 (2,2)。我们需要计算两人从 (0,0) 分别
	走到 (2,1) 和 (1,2)，路径并集的樱桃个数的最大值。

	虽然说，这是一个和原问题相似的子问题，但两条路径并不是相互独立的，同一个格子上的樱桃只能统计一次，我们需要考虑同一个格子重复经过的情况。

	如果把问题定义成：从 (0,0) 出发，A 走了 p 步，B 走了 q 步，分别走到 (i1,j1) 和 (i2,j2) 可以得到的樱桃个数的最大值，在 p != q 的
	情况下，比如 p < q，A 不知道哪些格子 B 已经走过了，无法计算重复经过的情况。所以，把子问题定义成两个人都走了相同的步数，也就是 p = q 的
	情况，才能直接计算出重复经过的情况，也就是两人走到同一个格子。在上面的例子中，我们需要计算两人从 (0,0) 出发，都走了 3 步，分别走到 (2,1)
	和 （1,2)，可以得到的樱桃个数的最大值。

	二、状态定义与状态转移方程
	定义 dfs(t,i1,j,i2,k) 表示两人从 (0,0) 出发，都走了 t 步，分别走到 (i1,j) 和 (i2,k)，可以得到的樱桃个数的最大值。

	状态纬度有点多，能否简化？
	注意到，从 (0,0) 出发，我们只能向下（这会让 i 加一）或向右（这会让 j 加一），所以 i + j 就是走的步数 t，所以 i1 和 i2 是多余的，可以去掉。

	于是，定义 dfs(t,j,k) 表示两人从 (0,0) 出发，都走了 t 步，分别走到 (t-j,j) 和 (t-k,k)，可以得到的樱桃个数的最大值。

	考虑 A 和 B 最后一步怎么走，也就是他们上一步的位置：
	· A 往下走，B 往下走，那么问题变成两人从 (0,0) 出发，都走了 t-1 步，分别走到 (t-1-j,j) 和 (t-1-k,k)，可以得到的樱桃个数的最大值，即 dfs(t-1,j,k)。
	· A 往下走，B 往右走，那么问题变成两人从 (0,0) 出发，都走了 t-1 步，分别走到 (t-1-j,j) 和 (t-k,k-1)，可以得到的樱桃个数的最大值，即 dfs(t-1,j,k-1)。
	· A 往右走，B 往下走，那么问题变成两人从 (0,0) 出发，都走了 t-1 步，分别走到 (t-j,j-1) 和 (t-1-k,k)，可以得到的樱桃个数的最大值，即 dfs(t-1,j-1,k)。
	· A 往右走，B 往右走，那么问题变成两人从 (0,0) 出发，都走了 t-1 步，分别走到 (t-j,j-1) 和 (t-k,k-1)，可以得到的樱桃个数的最大值，即 dfs(t-1,j-1,k-1)。
	这四种情况取最大值，再加上 grid[t-j][j] 和 grid[t-k][k]（两人位置重合时只加一个），就得到了 dfs(t,j,k)，即
			dfs(t,j,k) = max(dfs(t-1,j,k),dfs(t-1,j,k-1),dfs(t-1,j-1,k),dfs(t-1,j-1,k-1)) + val
	其中
			val = grid[t-j][j] + grid[t-k][k]    j != k
				  grid[t-j][j]					 j == k

	递归边界 1：如果 j,k,t-j,t-k,grid[t-j][j],grid[t-k][k] 中任何一个数小于 0（出界或者访问到 -1 格子），返回 「负无穷」
	递归边界 2：dfs(0,0,0) = grid[0][0]。
	递归入口：dfs(2n-2,n-1,n-1)，也就是答案。如果答案小于 0，说明路被荆棘（-1）挡住了，无法摘到任何一个樱桃，返回 0。

	三、递归搜索 + 保存递归返回值 = 记忆化搜索
*/

func cherryPickup(grid [][]int) int {
	n := len(grid)
	memo := make([][][]int, n*2-1)
	for i := range memo {
		memo[i] = make([][]int, n)
		for j := range memo[i] {
			memo[i][j] = make([]int, n)
			for k := range memo[i][j] {
				memo[i][j][k] = -1 // -1 表示没有计算过
			}
		}
	}
	var dfs func(int, int, int) int
	dfs = func(t, j, k int) int {
		// 不能出界，不能访问 -1 格子
		if j < 0 || k < 0 || t < j || t < k || grid[t-j][j] < 0 || grid[t-k][k] < 0 {
			return math.MinInt
		}
		if t == 0 { // 此时 j = k = 0
			return grid[0][0]
		}
		p := &memo[t][j][k]
		if *p != -1 { // 之前计算过
			return *p
		}
		res := max(dfs(t-1, j, k), dfs(t-1, j, k-1), dfs(t-1, j-1, k), dfs(t-1, j-1, k-1)) + grid[t-j][j]
		if k != j {
			res += grid[t-k][k]
		}
		*p = res // 记忆化
		return res
	}
	return max(dfs(n*2-2, n-1, n-1), 0)
}
