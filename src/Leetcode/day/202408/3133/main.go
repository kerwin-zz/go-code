package main

/*
	给你两个整数 n 和 x 。你需要构造一个长度为 n 的 正整数 数组 nums ，对于所有 0 <= i < n - 1 ，满足 nums[i + 1] 大于 nums[i] ，并且数组 nums 中所有元素的按位 AND 运算结果为 x 。

	返回 nums[n - 1] 可能的 最小 值。
*/

/*
	从集合的视角看，x 是每个 nums[i] 的子集。换句话说，nums[i] 一定是 x 的超集。

	例如 x=100100，那么 nums[i] 一定在如下序列中： 23 45位
								1[00]1[00] 1[00]1[01] 1[00]1[10] 1[00]1[11] 1[01]1[01]...
	只看下划线上的数，是一个自然数序列 0000,0001,0010,0011,0100,0101,⋯

	为了让 nums[n−1] 尽量小，我们应当选择 x 的超集中最小的 n 个数。
	所以把 x 的二进制中的 0 视作「空位」，往空位上填入 n−1，即为最小的 nums[n−1]。
	如果空位不足，往 x 的前面添加前导零即可。
*/

func minEnd(n int, x int) int64 {
	n-- // 先把 n 减一，这样下面讨论的 n 就是原来的 n-1
	i, j := 0, 0
	for n>>j > 0 {
		// x 的第 i 个比特值是 0，即「空位」
		if x>>i&1 == 0 {
			// 空位填入 n 的第 j 个比特值
			x |= n >> j & 1 << i
			j++
		}
		i++
	}
	return int64(x)
}

// 优化：把 x 取反，用 lowbit 枚举其中的 1，就是要填的空位。

func minEnd2(n int, x int) int64 {
	n--
	j := 0
	for t, lb := ^x, 0; n>>j > 0; t ^= lb {
		lb = t & -t
		x |= n >> j & 1 * lb
		j++
	}
	return int64(x)
}
