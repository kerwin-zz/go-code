package main

/*
	给你一个整数数组 nums 和一个 非负 整数 k 。如果一个整数序列 seq 满足在下标范围 [0, seq.length - 2] 中 最多只有
	k 个下标 i 满足 seq[i] != seq[i + 1] ，那么我们称这个整数序列为 好 序列。

	请你返回 nums 中 好子序列的最长长度。
*/

/*
	遍历到 x=nums[i] 时，维护以 x 结尾的、有至多 j 个「相邻不同」数对的子序列的最大长度，定义为 f[x][j]，初始值全为 0。
	对于 x，有三种决策：
	1. 不选：f[x][j] 不变。但其实这种情况无需考虑，因为直接把 x 加到以 x 结尾的好子序列的末尾，并不会增加「相邻不同」数对
	   的个数。为了让子序列尽量长，选肯定是更优的。
	2. 选，且 x 与子序列末尾相同，或者作为子序列的第一个数：f[x][j] 增加 1。
	3. 选，且 x 与子序列末尾不同：设末尾元素为 y，我们需要知道最大的 f[y][j−1]。

	优化:
	考虑维护 f[⋅][j−1] 中的最大值 mx，最大值对应的数字 num，以及 f[num2][j−1] 中的最大值 mx2，其中 num2 != num。
	于是：
	1. 如果 x != num，那么最大的 f[y][j−1] 就是 mx。
	2. 如果 x=num，那么最大的 f[y][j−1] 就是 mx2。
	把最大的 f[y][j−1] 记作 m，则 f[x][j] 更新为
						max(f[x][j]+1,m+1)

	进一步优化：
	只需要维护 mx，无需判断 x 和子序列的最后一个数是否相等。因为：
	1. 如果 x != num，那么转移和前文是一样的，用 mx+1 更新 f[x][j] 的最大值。、
	2. 如果 x=num，强行使用 mx+1，相当于用 f[x][j−1]+1 更新 f[x][j] 的最大值。注意这个转移是不符合状态定义的（应该用
	   f[x][j]+1），但由于 j 越大，能选的数越多，所以 f[x][j] >= f[x][j−1]，考虑到第二种决策会用 f[x][j]+1 更新
	   f[x][j]，这不会低于 f[x][j−1]+1。所以用 f[x][j−1]+1 更新 f[x][j] 的最大值其实不会改变 f[x][j]。

	综上所述，可以直接用 mx+1 更新 f[x][j] 的最大值，无需考虑次大值 mx2。
*/

func maximumLength(nums []int, k int) int {
	fs := make(map[int][]int)
	mx := make([]int, k+2)
	for _, x := range nums {
		if fs[x] == nil {
			fs[x] = make([]int, k+1)
		}
		f := fs[x]
		for j := k; j >= 0; j-- {
			f[j] = max(f[j], mx[j]) + 1
			mx[j+1] = max(mx[j+1], f[j])
		}
	}
	return mx[k+1]
}
