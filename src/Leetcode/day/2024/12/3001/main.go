package main

/*
	现有一个下标从 1 开始的 8 x 8 棋盘，上面有 3 枚棋子。
	给你 6 个整数 a 、b 、c 、d 、e 和 f ，其中：
	· (a, b) 表示白色车的位置。
	· (c, d) 表示白色象的位置。
	· (e, f) 表示黑皇后的位置。

	假定你只能移动白色棋子，返回捕获黑皇后所需的最少移动次数。
	请注意：
	· 车可以向垂直或水平方向移动任意数量的格子，但不能跳过其他棋子。
	· 象可以沿对角线方向移动任意数量的格子，但不能跳过其他棋子。
	· 如果车或象能移向皇后所在的格子，则认为它们可以捕获皇后。
	· 皇后不能移动。
*/

/*

	分类讨论：
	· 如果车能直接攻击到皇后，答案是 1。
	· 如果象能直接攻击到皇后，答案是 1。
	· 其他情况，答案一定是 2：
		· 如果车能攻击到皇后，但被象挡住，那么移走象，车就可以攻击到皇后，答案是 2。小知识：这在国际象棋中叫做「闪击」。
		· 如果象能攻击到皇后，但被车挡住，那么移走车，象就可以攻击到皇后，答案是 2。
		· 如果车不能攻击到皇后，那么车可以水平移动或者垂直移动，其中一种方式必定不会被象挡住，可以攻击到皇后，答案是 2。

	判断能否直接攻击到：
	· 对于车，如果和皇后在同一行或者同一列，且中间没有象，那么就可以直接攻击到皇后。
	· 对于象，如果和皇后在同一斜线，且中间没有车，那么就可以直接攻击到皇后
*/

// m 在 l 和 r 之间（写不写等号都可以）
func inBetween(l, m, r int) bool {
	return min(l, r) < m && m < max(l, r)
}

func minMovesToCaptureTheQueen(a int, b int, c int, d int, e int, f int) int {
	if a == e && (c != e || !inBetween(b, d, f)) || // 车直接攻击到皇后（同一行）
		b == f && (d != f || !inBetween(a, c, e)) || // 车直接攻击到皇后（同一列）
		c+d == e+f && (a+b != e+f || !inBetween(c, a, e)) || // 象直接攻击到皇后(右对角线)
		c-d == e-f && (a-b != e-f || !inBetween(c, a, e)) { // 象直接攻击到皇后(左对角线)
		return 1
	}
	return 2
}
