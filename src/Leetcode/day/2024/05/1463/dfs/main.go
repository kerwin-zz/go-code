package main

/*
	给你一个 rows x cols 的矩阵 grid 来表示一块樱桃地。 grid 中每个格子的数字表示你能获得的樱桃数目。

	你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 (0,0) 出发，机器人 2 从右上角格子 (0, cols-1) 出发。

	请你按照如下规则，返回两个机器人能收集的最多樱桃数目：

	从格子 (i,j) 出发，机器人可以移动到格子 (i+1, j-1)，(i+1, j) 或者 (i+1, j+1) 。
	当一个机器人经过某个格子时，它会把该格子内所有的樱桃都摘走，然后这个位置会变成空格子，即没有樱桃的格子。
	当两个机器人同时到达同一个格子时，它们中只有一个可以摘到樱桃。
	两个机器人在任意时刻都不能移动到 grid 外面。
	两个机器人最后都要到达 grid 最底下一行。
*/

/*
	一、寻找子问题
	看示例 1，把两个机器人分别叫做 A 和 B。
	我们要解决的原问题是：A 从 (0,0) 出发，B 从 (0,2) 出发，到达最后一行，可以得到的樱桃个数的最大值。

	考虑 A 和 B 第一步怎么走，例如：
	· 如果 A 第一步从 (0,0) 走到 (1,0)，B 第一步从 (0,2) 走到 (1,1)，那么接下来要解决的问题是：
	  A 从 (1,0) 出发，B 从 (1,1) 出发，到达最后一行，可以得到的樱桃个数的最大值。
	· 如果 A 第一步从 (0,0) 走到 (1,1)，B 第一步从 (0,2) 也走到 (1,1)，那么接下来要解决的问题是：
	  A 和 B 都从 (1,1) 出发，到达最后一行可以得到的樱桃个数的最大值。

	这些问题都是和原问题相似的、规模更小的子问题，所以可以用递归解决。

	二、状态定义和状态转移方程
	定义 dfs(i,j,k) 表示 A 从 (i,j) 出发，B 从 (i,k) 出发，到达最后一行，可以得到的樱桃个数的最大值。
	考虑 A 和 B 第一步怎么走，一共有 3 x 3 = 9 种情况，例如其中一种情况为：
	· A 往下走，B 往左下走，那么问题变成 A 从 (i+1,j) 出发，B 从 (i+1,k-1) 出发，到达最后一行，可以得到
	  的樱桃个数的最大值，即 dfs(i+1,j,k-1)。
	这九种情况取最大值，再加上 grid[i][j] 和 grid[i][k] (j == k 时只加一个)，就得到了 dfs(i,j,k)，
	即

		dfs(i,j,k) = val + max{ dfs(i+1,j-1,k-1), dfs(i+1,j-1,k), dfs(i+1,j-1,k+1),
								dfs(i+1,j,k-1),	  dfs(i+1,j,k),   dfs(i+1,j,k+1),
								dfs(i+1,j+1,k-1), dfs(i+1,j+1,k), dfs(i+1,j+1,k+1) }
	设 m 和 n 分别为 grid 的行数和列数。
	递归边界：如果 i = m, j < 0, j >= n, k < 0, k >= n 种任何一个成立（出界），返回 0。也可以对 i == m 的
			情况返回 0，其余出界情况返回 -∞。
	递归入口：dfs(0,0,n-1)，也就是答案。

	三、递归搜索 + 保存递归返回值 = 记忆化搜索
*/

func cherryPickup(grid [][]int) int {
	m, n := len(grid), len(grid[0])
	memo := make([][][]int, m)
	for i := range memo {
		memo[i] = make([][]int, n)
		for j := range memo[i] {
			memo[i][j] = make([]int, n)
			for k := range memo[i][j] {
				memo[i][j][k] = -1 // -1 表示没有计算过
			}
		}
	}
	var dfs func(int, int, int) int
	dfs = func(i, j, k int) int {
		if i == m || j < 0 || j >= n || k < 0 || k >= n {
			return 0
		}
		p := &memo[i][j][k]
		if *p != -1 { // 之前计算过
			return *p
		}
		res := 0
		for j2 := j - 1; j2 <= j+1; j2++ {
			for k2 := k - 1; k2 <= k+1; k2++ {
				res = max(res, dfs(i+1, j2, k2))
			}
		}
		res += grid[i][j]
		if j != k {
			res += grid[i][k]
		}
		*p = res // 记忆化
		return res
	}
	return dfs(0, 0, n-1)
}
