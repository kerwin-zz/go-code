package dfs

import "math"

/*
	给你一个整数数组，返回它的某个 非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。换句话说，
	你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，
	然后该子数组（剩下）的元素总和是所有子数组之中最大的。

	注意，删除一个元素后，子数组 不能为空。
*/

/*
	寻找子问题：
	最暴力的做法是枚举子数组的左右端点，以及要删除的元素。这种做法显然会超时。保留「枚举子数组的右端点」这一想法，看看有没有可以优化的地方。

	对于示例 1 中的数组 [1,−2,0,3]，假设元素和最大的连续子数组的右端点是 3。设原问题为：「子数组的右端点是 3，且至多删除一个数，子数组元素和的最大值是多少？」
	这个原问题可以拆分成两个问题：
	1. 子数组的右端点是 3，且“不能”删除数字，子数组元素和的最大值是多少？
		· 如果不选 3 左边的数，那么子数组就是 [3]。
		· 如果选 3 左边的数，那么需要解决的问题为：「子数组的右端点是 0，且不能删除数字，子数组元素和的最大值是多少？」
	2. 子数组的右端点是 3，且“必须”删除一个数字，子数组元素和的最大值是多少？
		· 如果不选 3 左边的数，那么必须删除 3，但这违背了题目要求：「（删除后）子数组中至少应当有一个元素」。所以不考虑这种情况。
		· 如果选 3 左边的数：
			a. 如果不删除 3，那么需要解决的问题为：「子数组的右端点是 0，且必须删除一个数组，子数组元素和的最大值是多少？」
			b. 如果删除 3，那么需要解决的问题为：「子数组的右端点是 0，且不能删除数字，子数组元素和的最大值是多少？」

	状态转移方程：
	根据上面的讨论，递归参数需要一个 i，表示子数组的右端点是 arr[i]。此外，需要知道是否可以删除数字，所以递归参数还需要一个 j。其中 j=0 表示不能删除数字，j=1
	表示必须删除一个数。

	定义 dfs(i,j) 表示子数组的右端点是 arr[i]，不能/必须 删除数字的情况下，子数组元素和的最大值。

	根据上面讨论出的子问题，可以得到：
	· 如果 j = 0（不能删除）：
		· 如果不选 arr[i] 左边的数，那么 dfs(i,0) = arr[i]。
		· 如果选 arr[i] 左边的数，那么 dfs(i,0) = dfs(i-1,0) + arr[i]。
	· 如果 j = 1（必须删除）：
		· 如果不删除 arr[i]，那么 dfs(i,1) = dfs(i−1,1) + arr[i]。
		· 如果删除 arr[i]，那么 dfs(i,1) = dfs(i−1,0)。
	取最大值，就得到了 dfs(i,j)。写成式子就是
							dfs(i,0) = max(dfs(i-1,0),0) + arr[i]
							dfs(i,1) = max(dfs(i-1,1)+arr[i],dfs(i-1,0))

	递归边界：dfs(−1,j)=−∞。这里 −1 表示子数组中「没有数字」，但题目要求子数组不能为空，所以这种情况不合法，用 −∞ 表示，这样取 max 的时候就自然会取到合法的情况。
	递归入口：dfs(i,j)。枚举子数组右端点 i，以及是否需要删除数字 j=0,1，取所有结果的最大值，作为答案。
*/

func maximumSum(arr []int) int {
	memo := make([][2]int, len(arr))
	for i := range memo {
		memo[i] = [2]int{math.MinInt, math.MinInt}
	}
	var dfs func(int, int) int
	dfs = func(i, j int) (res int) {
		if i < 0 {
			return math.MinInt / 2 // 防止负数相加溢出
		}
		p := &memo[i][j]
		if *p != math.MinInt { // 之前计算过
			return *p
		}
		defer func() { *p = res }() // 记忆化
		if j == 0 {
			return max(dfs(i-1, 0), 0) + arr[i]
		}
		return max(dfs(i-1, 1)+arr[i], dfs(i-1, 0))
	}
	ans := math.MinInt
	for i := range arr {
		ans = max(ans, dfs(i, 0), dfs(i, 1))
	}
	return ans
}
