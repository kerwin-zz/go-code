package main

/*
	给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。

	已知存在楼层 f ，满足 0 <= f <= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。

	每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 <= x <= n）。如果鸡蛋碎了，你就不能再次使用它。
	如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。

	请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？
*/

/*
	一、寻找子问题
	反过来，如果已知答案（操作次数），n 最大可以是多少？

	第一个例子
	假设我们有 i=5 次操作机会，有 j=2 枚鸡蛋。
	第一次操作，你打算在几楼扔第一枚鸡蛋？
	你可能会想：搏一搏，单车变摩托。楼层越高越好嘛，如果鸡蛋没碎，这对我们会更有利。
	最高可以在几楼扔？可以在 6 楼扔吗？
	不能。万一赌错鸡蛋碎了，后面就只能依次在 1,2,3,4,5 楼扔第二枚鸡蛋，最坏情况下，总共要操作 6 次。
	所以第一次操作的最优做法，是在 5 楼扔第一枚鸡蛋：
	· 即使鸡蛋碎了，后续也只需要依次在 1,2,3,4 楼扔第二枚鸡蛋，最坏情况下，总共要操作 1+4=5 次。注意这是一个 i=4, j=1 的子问题
	· 如果鸡蛋没碎，现在还剩下 4 次扔蛋机会。问题变成 i=4, j=2 的子问题。这个子问题的答案（等于 10），加上 5，就是原问题的答案（等于 15）。

	第二个例子
	假设我们有 i=6 次操作机会，有 j=3 枚鸡蛋。
	第一次操作，你打算在几楼扔第一枚鸡蛋？
	可以在 17 楼扔吗？
	不能。如果鸡蛋碎了，问题就变成 i=5,j=2 的子问题（答案等于 15），我们无法确定（题干中的）f 的值是否等于 16。
	所以第一次操作的最优做法，是在 16 楼扔第一枚鸡蛋：
	· 如果鸡蛋碎了，问题变成 i=5, j=2 的子问题（答案等于 15），由于只需要在 [1,15] 中扔鸡蛋，所以可以确定 f 的值。
	· 如果鸡蛋没碎，问题变成 i=5, j=3 的子问题。这个子问题的答案，加上 16，就是原问题的答案。
	由于这些问题都是和原问题相似的、规模更小的子问题，可以用递归解决。

	二、状态定义与状态转移方程
	根据上面的讨论，定义状态为 dfs(i,j)，表示在有 i 次操作机会和 j 枚鸡蛋的情况下，可以让我们能确定 f 值的最大建筑层数。

	在 dfs(i−1,j−1)+1 楼扔第一枚鸡蛋：
	· 如果鸡蛋碎了，接下来只需要在 [1,dfs(i−1,j−1)] 中扔鸡蛋，就可以确定 f 的值。
	· 如果鸡蛋没碎，问题变成在有 i−1 次操作机会和 j 枚鸡蛋的情况下，可以让我们能确定 f 值的最大建筑层数。这个子问题的答案
	  dfs(i−1,j)，加上 dfs(i−1,j−1)+1，就是原问题的答案 dfs(i,j)。
	所以有
					dfs(i,j)=dfs(i−1,j)+dfs(i−1,j−1)+1
	递归边界：dfs(0,j)=dfs(i,0)=0。无法扔鸡蛋。
	递归入口：枚举 i=1,2,3,⋯，首个满足 dfs(i,k) ≥ n 的 i 是答案。
*/

func superEggDrop(k int, n int) int {
	memo := [][]int{{}}
	var dfs func(int, int) int
	dfs = func(i, j int) int {
		if i == 0 || j == 0 {
			return 0
		}
		p := &memo[i][j]
		if *p != 0 {
			return *p
		}
		*p = dfs(i-1, j) + dfs(i-1, j-1) + 1
		return *p
	}
	for i := 1; ; i++ {
		memo = append(memo, make([]int, k+1))
		if dfs(i, k) >= n {
			return i
		}
	}
}

func superEggDrop2(k int, n int) int {
	f := make([][]int, n+1)
	f[0] = make([]int, k+1)
	for i := 1; ; i++ {
		f[i] = make([]int, k+1)
		for j := 1; j <= k; j++ {
			f[i][j] = f[i-1][j] + f[i-1][j-1] + 1
		}
		if f[i][k] >= n {
			return i
		}
	}
}

func superEggDrop3(k int, n int) int {
	f := make([]int, k+1)
	for i := 1; ; i++ {
		for j := k; j > 0; j-- {
			f[j] += f[j-1] + 1
		}
		if f[k] >= n {
			return i
		}
	}
}
